// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package iamanager

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// IAManagerClient is the client API for IAManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IAManagerClient interface {
	GetCertTypes(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CertTypes, error)
	FinishProvisioning(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	Clear(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SetOwner(ctx context.Context, in *SetOwnerRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...grpc.CallOption) (*CreateKeyResponse, error)
	ApplyCert(ctx context.Context, in *ApplyCertRequest, opts ...grpc.CallOption) (*ApplyCertResponse, error)
	GetCert(ctx context.Context, in *GetCertRequest, opts ...grpc.CallOption) (*GetCertResponse, error)
	SetUsers(ctx context.Context, in *Users, opts ...grpc.CallOption) (*empty.Empty, error)
	RegisterService(ctx context.Context, in *RegisterServiceRequest, opts ...grpc.CallOption) (*RegisterServiceResponse, error)
	UnregisterService(ctx context.Context, in *UnregisterServiceRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	EncryptDisk(ctx context.Context, in *EncryptDiskRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type iAManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewIAManagerClient(cc grpc.ClientConnInterface) IAManagerClient {
	return &iAManagerClient{cc}
}

func (c *iAManagerClient) GetCertTypes(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CertTypes, error) {
	out := new(CertTypes)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAManager/GetCertTypes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAManagerClient) FinishProvisioning(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAManager/FinishProvisioning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAManagerClient) Clear(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAManager/Clear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAManagerClient) SetOwner(ctx context.Context, in *SetOwnerRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAManager/SetOwner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAManagerClient) CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...grpc.CallOption) (*CreateKeyResponse, error) {
	out := new(CreateKeyResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAManager/CreateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAManagerClient) ApplyCert(ctx context.Context, in *ApplyCertRequest, opts ...grpc.CallOption) (*ApplyCertResponse, error) {
	out := new(ApplyCertResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAManager/ApplyCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAManagerClient) GetCert(ctx context.Context, in *GetCertRequest, opts ...grpc.CallOption) (*GetCertResponse, error) {
	out := new(GetCertResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAManager/GetCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAManagerClient) SetUsers(ctx context.Context, in *Users, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAManager/SetUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAManagerClient) RegisterService(ctx context.Context, in *RegisterServiceRequest, opts ...grpc.CallOption) (*RegisterServiceResponse, error) {
	out := new(RegisterServiceResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAManager/RegisterService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAManagerClient) UnregisterService(ctx context.Context, in *UnregisterServiceRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAManager/UnregisterService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAManagerClient) EncryptDisk(ctx context.Context, in *EncryptDiskRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAManager/EncryptDisk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IAManagerServer is the server API for IAManager service.
// All implementations must embed UnimplementedIAManagerServer
// for forward compatibility
type IAManagerServer interface {
	GetCertTypes(context.Context, *empty.Empty) (*CertTypes, error)
	FinishProvisioning(context.Context, *empty.Empty) (*empty.Empty, error)
	Clear(context.Context, *ClearRequest) (*empty.Empty, error)
	SetOwner(context.Context, *SetOwnerRequest) (*empty.Empty, error)
	CreateKey(context.Context, *CreateKeyRequest) (*CreateKeyResponse, error)
	ApplyCert(context.Context, *ApplyCertRequest) (*ApplyCertResponse, error)
	GetCert(context.Context, *GetCertRequest) (*GetCertResponse, error)
	SetUsers(context.Context, *Users) (*empty.Empty, error)
	RegisterService(context.Context, *RegisterServiceRequest) (*RegisterServiceResponse, error)
	UnregisterService(context.Context, *UnregisterServiceRequest) (*empty.Empty, error)
	EncryptDisk(context.Context, *EncryptDiskRequest) (*empty.Empty, error)
	mustEmbedUnimplementedIAManagerServer()
}

// UnimplementedIAManagerServer must be embedded to have forward compatible implementations.
type UnimplementedIAManagerServer struct {
}

func (UnimplementedIAManagerServer) GetCertTypes(context.Context, *empty.Empty) (*CertTypes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCertTypes not implemented")
}
func (UnimplementedIAManagerServer) FinishProvisioning(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishProvisioning not implemented")
}
func (UnimplementedIAManagerServer) Clear(context.Context, *ClearRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedIAManagerServer) SetOwner(context.Context, *SetOwnerRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOwner not implemented")
}
func (UnimplementedIAManagerServer) CreateKey(context.Context, *CreateKeyRequest) (*CreateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKey not implemented")
}
func (UnimplementedIAManagerServer) ApplyCert(context.Context, *ApplyCertRequest) (*ApplyCertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyCert not implemented")
}
func (UnimplementedIAManagerServer) GetCert(context.Context, *GetCertRequest) (*GetCertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCert not implemented")
}
func (UnimplementedIAManagerServer) SetUsers(context.Context, *Users) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUsers not implemented")
}
func (UnimplementedIAManagerServer) RegisterService(context.Context, *RegisterServiceRequest) (*RegisterServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterService not implemented")
}
func (UnimplementedIAManagerServer) UnregisterService(context.Context, *UnregisterServiceRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterService not implemented")
}
func (UnimplementedIAManagerServer) EncryptDisk(context.Context, *EncryptDiskRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptDisk not implemented")
}
func (UnimplementedIAManagerServer) mustEmbedUnimplementedIAManagerServer() {}

// UnsafeIAManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IAManagerServer will
// result in compilation errors.
type UnsafeIAManagerServer interface {
	mustEmbedUnimplementedIAManagerServer()
}

func RegisterIAManagerServer(s grpc.ServiceRegistrar, srv IAManagerServer) {
	s.RegisterService(&IAManager_ServiceDesc, srv)
}

func _IAManager_GetCertTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAManagerServer).GetCertTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAManager/GetCertTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAManagerServer).GetCertTypes(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAManager_FinishProvisioning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAManagerServer).FinishProvisioning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAManager/FinishProvisioning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAManagerServer).FinishProvisioning(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAManager_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAManagerServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAManager/Clear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAManagerServer).Clear(ctx, req.(*ClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAManager_SetOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAManagerServer).SetOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAManager/SetOwner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAManagerServer).SetOwner(ctx, req.(*SetOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAManager_CreateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAManagerServer).CreateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAManager/CreateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAManagerServer).CreateKey(ctx, req.(*CreateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAManager_ApplyCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAManagerServer).ApplyCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAManager/ApplyCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAManagerServer).ApplyCert(ctx, req.(*ApplyCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAManager_GetCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAManagerServer).GetCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAManager/GetCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAManagerServer).GetCert(ctx, req.(*GetCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAManager_SetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Users)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAManagerServer).SetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAManager/SetUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAManagerServer).SetUsers(ctx, req.(*Users))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAManager_RegisterService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAManagerServer).RegisterService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAManager/RegisterService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAManagerServer).RegisterService(ctx, req.(*RegisterServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAManager_UnregisterService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAManagerServer).UnregisterService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAManager/UnregisterService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAManagerServer).UnregisterService(ctx, req.(*UnregisterServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAManager_EncryptDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAManagerServer).EncryptDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAManager/EncryptDisk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAManagerServer).EncryptDisk(ctx, req.(*EncryptDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IAManager_ServiceDesc is the grpc.ServiceDesc for IAManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IAManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iamanager.v1.IAManager",
	HandlerType: (*IAManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCertTypes",
			Handler:    _IAManager_GetCertTypes_Handler,
		},
		{
			MethodName: "FinishProvisioning",
			Handler:    _IAManager_FinishProvisioning_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _IAManager_Clear_Handler,
		},
		{
			MethodName: "SetOwner",
			Handler:    _IAManager_SetOwner_Handler,
		},
		{
			MethodName: "CreateKey",
			Handler:    _IAManager_CreateKey_Handler,
		},
		{
			MethodName: "ApplyCert",
			Handler:    _IAManager_ApplyCert_Handler,
		},
		{
			MethodName: "GetCert",
			Handler:    _IAManager_GetCert_Handler,
		},
		{
			MethodName: "SetUsers",
			Handler:    _IAManager_SetUsers_Handler,
		},
		{
			MethodName: "RegisterService",
			Handler:    _IAManager_RegisterService_Handler,
		},
		{
			MethodName: "UnregisterService",
			Handler:    _IAManager_UnregisterService_Handler,
		},
		{
			MethodName: "EncryptDisk",
			Handler:    _IAManager_EncryptDisk_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "iamanager.proto",
}
